<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <meta charset="utf-8">
        <title>Tortik</title>
        <meta name="description" content="">
        <meta http-equiv="cleartype" content="on">

        <link rel="stylesheet" media="all" charset="utf-8" href="css/style.css" />
        <link href="css/default.min.css" media="all" rel="stylesheet" type="text/css" />
    </head>
    <body>
    <div class="page">
	    <h1 class="page-head">Tortik</h1>
	    <h3>a micro framework atop of Tornado</h3>
	    <div align="center">
	    	<img src="img/parallel.png" style="width: 432px;" />
	    </div>

	    <p align="center">Tortik provides an ability to enchance your tornado web app to the next level.</p>

	    <h2>Preprocessors</h2>

	    <div class="content">
	    	<p>Provides a group of asynchronous handlers before main handler starts to work.</p>
	    	<p><pre>
<code>def session(handler, callback):
	def _cb():
        # json/xml parsed automatically and put into handler.responses[&lt;request name&gt;].data
        handler.session = handler.responses['session'].data
        callback()

	handler.fetch_requests(
        handler.make_request( # creates HTTPRequest
            name='session',  # request name
            method='GET',
            full_url=options.session_url,
            headers=headers,
            data=data, # data is a dict of parameters to pass to backend
        ),
        callback=_cb,
        stage='session' # something about stages goes later
    )

def Page(tortik.page.RequestHandler):
	preprocessors = [
	    session,
	    pagedata
	]

	def get(self):  # all get/post/.. methods are asynchronous by default
	    # self.session is available now
	    self.complete() # use it instead of self.finish to apply postprocessors 
</code></pre></p>
	    </div>

	    <h2>Stages</h2>
        <div class="content">
            <p>All the request handling could be divided into parts: fetching session, do some user related stuff (request backends for data or post smth.), render a page. This parts are called stages in Tortik. Stages provide a better way to find perfomance issues or bottlenecks in your application.</p>
            <p>Stage name could be passed as a parameter to <i>fetch_requests</i> method (default is <i>page</i>):</p>
<p><pre><code class="python">handler.fetch_requests(
    ...
    callback=_cb,
    stage='session'
)                
</code></pre></p>   
            <p>or could be done manually:</p>         
            <p><pre>
<code>handler.log.stage_started('render')
# do some hard render stuff
handler.log.stage_complete('render')</code></pre></p>   
            <p>After request handle completed a debug note would be printed:</p>
            <p><pre>
<code>MONIK handler=hhmobile.pages.Page method=GET code=200 total=93 session=13.98 page=47.14 render=21.77 translation=7.30</code></pre></p>   
            <p>which means that request done with <i>hhmobile.pages.Page</i> and took total 93ms with stages: session, page, render and translation</p>
        </div>  

	    <h2>Request handler</h2>
        <div class="content">
            <p>All the standart Tornado method handlers (get, post, ...) are @asynchronous by default and you don't need to put this decorator every time.</p>
            <p>The output data could be prepared by two ways:</p>
            <ul>
                <li>with <i>self.add</i> method</li>
                <li>as an argument to <i>self.complete</i> </li>
            </ul>
<p><pre><code class="python">def Page(tortik.page.RequestHandler):
    self.add('main_data', 'Hello, World!')
    self.complete({'some_data': 'Hello, World!'})
</code></pre></p>
            <p>The difference is that in the second option your data passes directly to the postprocessors (more on them later) or to the <i>self.finish</i> method if there is no postprocessors in your handler.</p>
            <p>In the first option your data is available in <i>self.get_data</i> method and could be processed later.</p>
        </div>

        <h2>Postprocessors</h2>
        <div class="content">
        <p>Postprocessors is a set of handlers on your output data which run after <i>complete</i> method called.</p>
<p><pre><code class="python">def template(handler, data, callback): # data is an argument passed to self.complete method
    out = template_engine.render(handler.template_name,
                                 data=handler.get_data(), # dict of our self.add calls {'main_data': 'Hello, World!'}
                                 ...)
    callback(handler, out)

def Page(tortik.page.RequestHandler):
    postprocessors = [
        template
    ]

    def get(self):
        # do some handler stuff
        self.add('main_data', 'Hello, World!')
        self.complete()
</code></pre></p>
        <p>The result of <i>template_engine.render</i> would be transfered to the client.</p>
        </div>

	    <h2>Debug and logging</h2>
        <div class="content">
        <p>Tortik provides a standart method for logging with <i>self.log</i> object.</p>
        <p>But the most powerfull feature is a debug page there you can see your page processing:</p>
        <img src="img/debug.png">
        <p>Information about every request to the backend:</p>
        <img src="img/debug_more.png">
        <p>And handler data (result dict of the <i>self.add</i> calls):</p>
        <img src="img/debug_output.png">

        <p>You should pass a <i>?debug</i> argument to the page and page processing would be displayed.</p>
        
        </div>
	</div>
    <script type="text/javascript" src="js/highlight.min.js" charset="utf-8"></script>
    <script type="text/javascript">
        hljs.tabReplace = '&nbsp;&nbsp;&nbsp;&nbsp;';
        hljs.initHighlightingOnLoad();
    </script>
    </body>
</html>    